import { carouselNavigation } from './carouselNavigation';
import { progressBar } from './progressBar';
import { carouselFactory } from './carouselAnimations/carouselFactory';
import { concreteSubject } from './helpers/concreteSubject';
import { listener } from './helpers/listener';
import { validationData } from './helpers/validationData';
import { pageVisibility } from './helpers/pageVisibility';
import { Calculation } from './helpers/calculation';
export class PapaCarousel {
    constructor(builder) {
        this.identificatorLoop = 'carouselLoop';
        this.transitionEndFn = (e) => {
            this.addStyles(e.srcElement, this.carousel.starterPack());
            listener.removeListener(this.transitionEndFn);
        };
        this.carouselLoopFn = () => {
            return setTimeout(() => {
                const currentEl = this.elements[this.calculation.getIndex()];
                listener.addListener('transitionend', currentEl, this.transitionEndFn);
                this.slideCarousel(1);
                listener.setTimeoutFn(this.identificatorLoop, this.carouselLoopFn());
            }, this.timePerSlide);
        };
        const parentEl = validationData.parentChecker(builder.getParent());
        this.timePerSlide = validationData.timePerSlideChecker(builder.getTimePerSlide());
        this.carousel = carouselFactory.getCarousel(validationData.typeChecker(builder.getType()));
        this.elements = validationData.elementsChecker(builder.getElements(), parentEl);
        if (validationData.buttonsChecker(builder.getButtons())) {
            carouselNavigation.initButtons(parentEl);
            concreteSubject.attach(this.onNavClick.bind(this));
        }
        if (validationData.progressBarChecker(builder.getProgressBar())) {
            progressBar.initBar(parentEl, this.timePerSlide);
        }
        this.transitionProperty = `${this.carousel.getTransitionProperties()} ${validationData.timingFnChecker(builder.getTimingFn())}ms 
            ${validationData.transitionFnTypesChecker(builder.getTransitionFn())}`;
        this.calculation = new Calculation(this.elements.length - 1);
        pageVisibility.initListener();
        this.initSlider();
    }
    slideCarousel(newIndex, fn) {
        const [currentEl, newEl] = [this.elements[this.calculation.getIndex()], this.elements[this.calculation.getIndex(newIndex)]];
        this.addStyles(currentEl, this.carousel.hideAnimation());
        this.addStyles(newEl, this.carousel.showAnimation());
        if (typeof fn === 'function')
            fn(currentEl);
    }
    initSlider(resetSlider) {
        if (!resetSlider)
            this.prepareItems();
        listener.setTimeoutFn(this.identificatorLoop, this.carouselLoopFn());
    }
    prepareItems() {
        this.elements.map((e, i) => this.addStyles(e, Object.assign({}, (i === this.calculation.getIndex() ? this.carousel.showAnimation() : this.carousel.starterPack()), { transition: this.transitionProperty })));
    }
    addStyles(el, styles) {
        for (let [property, value] of Object.entries(styles))
            el.style[property] = value;
    }
    onNavClick(args) {
        listener.clearTimeoutFn(this.identificatorLoop);
        if (args === 'pageHidden')
            return;
        if (typeof args === 'number')
            this.slideCarousel(args, el => listener.addListener('transitionend', el, this.transitionEndFn));
        this.initSlider(true);
    }
}
//# sourceMappingURL=papaCarousel.js.map